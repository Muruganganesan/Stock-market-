# -*- coding: utf-8 -*-
"""Stock_MARKET2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W8TmFtmcPR6dV7ECBAhLa77yjZQDGkxl
"""

!pip install mysql-connector-python

import pandas as pd
import re
import mysql.connector

# Establish database connection (make sure you have the correct credentials)
connection = mysql.connector.connect(
  host = "gateway01.ap-southeast-1.prod.aws.tidbcloud.com",
  port = 4000,
  user = "MFbdJWf4C73eB9h.root",
  password = "yw9C9ScImIB0y4Xt",
  database = "Stock_market",
)
mycursor = connection.cursor(buffered=True)

mycursor.execute("SHOW TABLES")
tables = mycursor.fetchall()
for table in tables:
    print(table)

mycursor.execute("SELECT * FROM Stock_2024")
out=mycursor.fetchall()
from tabulate import tabulate
print(tabulate(out, headers=[i[0] for i in mycursor.description], tablefmt='psql'))

import pandas as pd
from tabulate import tabulate

# SQL query to calculate annual revenue and get top 10 stocks
mycursor.execute("""
    SELECT
        ticker,
        SUM(open * volume) AS annual_revenue
    FROM
        Stock_2024
    GROUP BY
        ticker
    ORDER BY
        annual_revenue DESC
    LIMIT 10
""")

out = mycursor.fetchall()
formatted_out = [(ticker, f"₹{round(revenue):,}") for ticker, revenue in out]

df = pd.DataFrame(formatted_out, columns=["Ticker", "Annual Revenue (Full Value)"])

df.to_csv('top_10_green_stocks.csv', index=False)

print(tabulate(df, headers='keys', tablefmt='github', showindex=False))

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# SQL query execution
mycursor.execute("""
    SELECT
        ticker,
        SUM(open * volume) AS annual_revenue
    FROM
        Stock_2024
    GROUP BY
        ticker
    ORDER BY
        annual_revenue DESC
    LIMIT 10
""")
out = mycursor.fetchall()

columns = [i[0] for i in mycursor.description]

df = pd.DataFrame(out, columns=columns)

plt.figure(figsize=(12, 6))
sns.barplot(x='ticker', y='annual_revenue', data=df, palette='viridis')

plt.title('Top 10 Green Stocks', fontsize=16)
plt.xlabel('Ticker', fontsize=12)
plt.ylabel('Annual Revenue', fontsize=12)
plt.xticks(rotation=45)
plt.tight_layout()

plt.show()

import pandas as pd
from tabulate import tabulate

# SQL query to calculate annual revenue and get top 10 stocks
mycursor.execute("""
    SELECT
        ticker,
        SUM(open * volume) AS annual_revenue
    FROM
        Stock_2024
    GROUP BY
        ticker
    ORDER BY
        annual_revenue ASC
    LIMIT 10
""")

out = mycursor.fetchall()
formatted_out = [(ticker, f"₹{round(revenue):,}") for ticker, revenue in out]

df = pd.DataFrame(formatted_out, columns=["Ticker", "Annual Revenue (Full Value)"])

df.to_csv('top_10_red_stocks.csv', index=False)

print(tabulate(df, headers='keys', tablefmt='github', showindex=False))



import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Execute the SQL query for bottom 10 stocks by annual revenue
mycursor.execute("""
    SELECT
        ticker,
        SUM(open * volume) AS annual_revenue
    FROM
        Stock_2024
    GROUP BY
        ticker
    ORDER BY
        annual_revenue ASC
    LIMIT 10
""")
out = mycursor.fetchall()

# Convert to DataFrame
columns = [i[0] for i in mycursor.description]
df = pd.DataFrame(out, columns=columns)

# Plot using seaborn
plt.figure(figsize=(12, 6))
sns.barplot(x='ticker', y='annual_revenue', data=df, palette='magma')

# Add title and labels
plt.title('Bottom 10 Stocks by Annual Revenue (2024)', fontsize=16)
plt.xlabel('Ticker', fontsize=12)
plt.ylabel('Annual Revenue', fontsize=12)
plt.xticks(rotation=45)
plt.tight_layout()

# Show plot
plt.show()

# Calculate the average price across all stocks:
mycursor.execute("""
    SELECT FLOOR(AVG(open)) AS average_price
    FROM Stock_2024;
""")
average_price = mycursor.fetchone()[0]
print(f"The average price across all stocks is: {average_price}")

# Calculate the average volume across all stocks:
mycursor.execute("""
    SELECT FLOOR(AVG(volume)) AS average_volume
    FROM Stock_2024;
""")
average_volume = mycursor.fetchone()[0]
print(f"The average volume across all stocks is: {average_volume}")

# prompt: Calculate daily returns for each stock: (Close Price - Previous Close Price) / Previous Close Price.

# Calculate daily returns
mycursor.execute("""
    SELECT date, ticker, close
    FROM Stock_2024
    ORDER BY ticker, date
""")
data = mycursor.fetchall()
df = pd.DataFrame(data, columns=['date', 'ticker', 'close'])
df['date'] = pd.to_datetime(df['date'])
df = df.set_index(['date', 'ticker'])
daily_returns = df.groupby('ticker')['close'].pct_change()

# Convert daily_returns to a list of lists for tabulate
daily_returns_list = []
for (date, ticker), value in daily_returns.items():
    daily_returns_list.append([date, ticker, value])

# Print the tabulated data
from tabulate import tabulate
print(tabulate(daily_returns_list, headers=["Date", "Ticker", "Daily Returns"], tablefmt="github"))

# prompt: Visualize the volatility of each stock over the past year by calculating the standard deviation of daily returns.

# Calculate daily returns
mycursor.execute("""
    SELECT date, ticker, open
    FROM Stock_2024
    ORDER BY ticker, date
""")
data = mycursor.fetchall()
df = pd.DataFrame(data, columns=['date', 'ticker', 'open'])
df['date'] = pd.to_datetime(df['date'])
df = df.set_index(['date', 'ticker'])
daily_returns = df.groupby('ticker')['open'].pct_change()

# Calculate volatility (standard deviation of daily returns)
volatility = daily_returns.groupby('ticker').std()

print(volatility)

# prompt: Visualize the volatility of each stock over the past year by calculating the standard deviation of daily returns.

# Calculate daily returns
mycursor.execute("""
    SELECT date, ticker, open
    FROM Stock_2024
    ORDER BY ticker, date
""")
data = mycursor.fetchall()
df = pd.DataFrame(data, columns=['date', 'ticker', 'open'])
df['date'] = pd.to_datetime(df['date'])
df = df.set_index(['date', 'ticker'])
daily_returns = df.groupby('ticker')['open'].pct_change()

# Calculate volatility (standard deviation of daily returns)
volatility = daily_returns.groupby('ticker').std()

# Plotting
plt.figure(figsize=(12, 6))
volatility.plot(kind='bar')
plt.title('Volatility of Stocks (Standard Deviation of Daily Returns)')
plt.xlabel('Ticker')
plt.ylabel('Volatility')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Sort volatility in descending order and get the top 10
top_10_volatility = volatility.sort_values(ascending=False).head(10)
top_10_volatility.to_csv('top_10_volatility.csv', index=True)  # Set index=True if you want to keep the index in the CSV file

print(top_10_volatility)

# Sort volatility in descending order and get the top 10
top_10_volatility = volatility.sort_values(ascending=False).head(10)

# Plotting
plt.figure(figsize=(12, 6))
top_10_volatility.plot(kind='bar', color='skyblue')
plt.title('Volatility of Top 10 Most Volatile Stocks', fontsize=16)
plt.xlabel('Ticker', fontsize=12)
plt.ylabel('Volatility (Standard Deviation of Daily Returns)', fontsize=12)
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.tight_layout()
plt.show()

# prompt: Show the cumulative return of each stock from the beginning of the year to the end.

# Calculate daily returns
mycursor.execute("""
    SELECT date, ticker, open
    FROM Stock_2024
    ORDER BY ticker, date
""")
data = mycursor.fetchall()
df = pd.DataFrame(data, columns=['date', 'ticker', 'open'])
df['date'] = pd.to_datetime(df['date'])
df = df.set_index(['date', 'ticker'])
daily_returns = df.groupby('ticker')['open'].pct_change()

# Calculate cumulative returns
cumulative_returns = (1 + daily_returns).cumprod() - 1

# Convert cumulative_returns to a list of lists for tabulate
cumulative_returns_list = []  # Define the list
for (date, ticker), value in cumulative_returns.items():
    cumulative_returns_list.append([date, ticker, value])

# Display cumulative returns using tabulate
from tabulate import tabulate
print(tabulate(cumulative_returns_list, headers=["Date", "Ticker", "Cumulative Returns"], tablefmt="github"))

import pandas as pd
from tabulate import tabulate

# Group by ticker and get the last cumulative return for each ticker
last_cumulative_returns = cumulative_returns.groupby('ticker').last()

# Sort by cumulative returns in descending order and get the top 5
top_5_cumulative_returns = last_cumulative_returns.sort_values(ascending=False).head(5)

# Convert to a list of lists for tabulate
top_5_list = []

for ticker, value in top_5_cumulative_returns.items():
    top_5_list.append([ticker, value])

# Convert top_5_list to a DataFrame
top_5_df = pd.DataFrame(top_5_list, columns=["Ticker", "Cumulative Returns"])

# Saving the DataFrame to CSV
top_5_df.to_csv('top_5_cumulative_returns.csv', index=False)

# Optionally, print the result in a formatted table style
print(tabulate(top_5_list, headers=["Ticker", "Cumulative Returns"], tablefmt="github"))

# Get the top 5 tickers with the highest cumulative returns on the last date
last_date = cumulative_returns.index.get_level_values('date').max()
top_5_cumulative_returns = cumulative_returns.loc[last_date].sort_values(ascending=False).head(5)

# Plotting the line chart
plt.figure(figsize=(10, 6))
top_5_cumulative_returns.plot(kind='line', marker='o')
plt.title('Top 5 Cumulative Returns')
plt.xlabel('Ticker')
plt.ylabel('Cumulative Returns')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Calculate daily percentage change for closing prices
mycursor.execute("""
    SELECT date, ticker, close
    FROM Stock_2024
    ORDER BY ticker, date
""")
data = mycursor.fetchall()
df = pd.DataFrame(data, columns=['date', 'ticker', 'close'])
df['date'] = pd.to_datetime(df['date'])
df = df.pivot(index='date', columns='ticker', values='close').pct_change()

# Calculate the correlation matrix
correlation_matrix = df.corr()

# Display the correlation matrix using tabulate
print(tabulate(correlation_matrix, headers='keys', tablefmt='psql'))

# prompt: Objective: Provide monthly breakdowns of the top-performing and worst-performing stocks.
# Reason: This analysis will allow users to observe more granular trends and understand which stocks are gaining or losing momentum on a monthly basis.

# Fetch the necessary data from the database
mycursor.execute("""
    SELECT date, ticker, close
    FROM Stock_2024
    ORDER BY ticker, date
""")
data = mycursor.fetchall()
df = pd.DataFrame(data, columns=['date', 'ticker', 'close'])
df['date'] = pd.to_datetime(df['date'])

# Group the data by month and ticker
monthly_data = df.groupby([df['date'].dt.to_period('M'), 'ticker'])

# Example: Calculate the monthly average closing price
monthly_avg_close = monthly_data['close'].mean().unstack()

# Find the top and bottom performers each month
top_performers = monthly_avg_close.apply(lambda x: x.nlargest(3), axis=1) # Top 3
bottom_performers = monthly_avg_close.apply(lambda x: x.nsmallest(3), axis=1) # Bottom 3

print("Top Performers (Monthly Average Closing Price):")
print(top_performers)

print("\nBottom Performers (Monthly Average Closing Price):")
print(bottom_performers)


# Example Visualization (optional)
# Plot the monthly average closing price for the top 3 performers of the first month.
first_month_top = top_performers.iloc[0]

plt.figure(figsize=(10, 6))
for ticker in first_month_top.index:
  # Convert PeriodIndex to a list of strings for plotting
  x_values = [str(period) for period in monthly_avg_close.index]
  plt.plot(x_values, monthly_avg_close[ticker], label=ticker)

plt.title(f"Monthly Average Closing Price - Top 5 Performers ({monthly_avg_close.index[0]})")
plt.xlabel('Month')
plt.ylabel('Average Closing Price')
plt.legend()
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Group the stock data by month and calculate the monthly return for each stock in all tickers view in tabulate format

# Calculate monthly returns
monthly_returns = df.groupby([df['date'].dt.to_period('M'), 'ticker'])['close'].last().unstack().pct_change()

# Print the monthly returns in a tabulated format
print(tabulate(monthly_returns, headers='keys', tablefmt='psql'))

# Identify the top 5 profitable tickers based on percentage change for each month. View in table format.

import pandas as pd
from tabulate import tabulate
# Calculate monthly percentage change for closing prices
mycursor.execute("""
    SELECT date, ticker, close
    FROM Stock_2024
    ORDER BY ticker, date
""")
data = mycursor.fetchall()
df = pd.DataFrame(data, columns=['date', 'ticker', 'close'])
df['date'] = pd.to_datetime(df['date'])
df = df.pivot(index='date', columns='ticker', values='close').pct_change()

monthly_returns = df.resample('M').last().pct_change()

# Function to get top 5 tickers for each month
def get_top_5_monthly(monthly_returns_df):
    top_5_monthly = {}
    for month, row in monthly_returns_df.iterrows():
        top_5 = row.nlargest(5)
        top_5_monthly[month] = top_5
    return top_5_monthly

# Get the top 5 profitable tickers for each month
top_5_per_month = get_top_5_monthly(monthly_returns)

# Display in table format
for month, tickers in top_5_per_month.items():
    print(f"Top 5 Profitable Tickers for {month.strftime('%Y-%m')}:")
    data = [[ticker, percentage_change] for ticker, percentage_change in tickers.items()]
    print(tabulate(data, headers=['Ticker', 'Percentage Change'], tablefmt='grid'))
    print("\n")

# prompt: Identify the top 5 profitable tickers based on percentage change for each month. View in table format. and save csv

# ... (Your existing code)

# Convert the top_5_per_month dictionary to a DataFrame for easier CSV export
import pandas as pd
from io import StringIO

top_5_df_list = []
for month, tickers in top_5_per_month.items():
    for ticker, percentage_change in tickers.items():
        top_5_df_list.append([month.strftime('%Y-%m'), ticker, percentage_change])

top_5_df = pd.DataFrame(top_5_df_list, columns=['Month', 'Ticker', 'Percentage Change'])

# Save to CSV
top_5_df.to_csv('top_5_monthly_profitable_tickers.csv', index=False)

# prompt: Identify the top 5 losing tickers based on percentage change for each month. View in table format.

# Function to get bottom 5 tickers for each month
def get_bottom_5_monthly(monthly_returns_df):
    bottom_5_monthly = {}
    for month, row in monthly_returns_df.iterrows():
        bottom_5 = row.nsmallest(5)
        bottom_5_monthly[month] = bottom_5
    return bottom_5_monthly

# Get the bottom 5 losing tickers for each month
bottom_5_per_month = get_bottom_5_monthly(monthly_returns)

# Display in table format
for month, tickers in bottom_5_per_month.items():
    print(f"Bottom 5 Losing Tickers for {month.strftime('%Y-%m')}:")
    data = [[ticker, percentage_change] for ticker, percentage_change in tickers.items()]
    print(tabulate(data, headers=['Ticker', 'Percentage Change'], tablefmt='grid'))
    print("\n")

# prompt: Identify the top 5 losing tickers based on percentage change for each month. View in table format. and save csv

# Convert the bottom_5_per_month dictionary to a DataFrame for easier CSV export
bottom_5_df_list = []
for month, tickers in bottom_5_per_month.items():
    for ticker, percentage_change in tickers.items():
        bottom_5_df_list.append([month.strftime('%Y-%m'), ticker, percentage_change])

bottom_5_df = pd.DataFrame(bottom_5_df_list, columns=['Month', 'Ticker', 'Percentage Change'])

# Save to CSV
bottom_5_df.to_csv('bottom_5_monthly_losing_tickers.csv', index=False)

mycursor.execute("SELECT * FROM Stock_2024")
out=mycursor.fetchall()
from tabulate import tabulate
print(tabulate(out, headers=[i[0] for i in mycursor.description], tablefmt='psql'))

mycursor.execute("SELECT * FROM Sector_data")
out=mycursor.fetchall()
from tabulate import tabulate
print(tabulate(out, headers=[i[0] for i in mycursor.description], tablefmt='psql'))

mycursor.execute("SELECT * FROM Stock_2024")
out=mycursor.fetchall()
from tabulate import tabulate
print(tabulate(out, headers=[i[0] for i in mycursor.description], tablefmt='psql'))

# Merge Stock_2024 with Sector_data based on ticker to add the sector column
mycursor.execute("""
    SELECT s.*, se.sector
    FROM Stock_2024 s
    JOIN Sector_data se ON s.ticker = se.ticker;
""")

out = mycursor.fetchall()

# Use the column names from the merged query
columns = [i[0] for i in mycursor.description]
df = pd.DataFrame(out, columns=columns)

# Save the DataFrame to a CSV file
df.to_csv('stock_with_sector.csv', index=False)

print(tabulate(df, headers='keys', tablefmt='psql'))

mycursor.execute("SELECT * FROM Stock_with_sector")
out=mycursor.fetchall()
from tabulate import tabulate
print(tabulate(out, headers=[i[0] for i in mycursor.description], tablefmt='psql'))

# prompt: Provide a breakdown of stock performance by sector

# Calculate sector performance metrics (e.g., average monthly return)
mycursor.execute("""
    SELECT sector, AVG(monthly_return) AS avg_monthly_return
    FROM (
        SELECT s.sector, (s.close - LAG(s.close, 1) OVER (PARTITION BY s.ticker ORDER BY s.date)) / LAG(s.close, 1) OVER (PARTITION BY s.ticker ORDER BY s.date) AS monthly_return
        FROM Stock_with_sector s
    ) AS subquery
    GROUP BY sector;
""")

sector_performance = mycursor.fetchall()

# Display sector performance
print(tabulate(sector_performance, headers=['Sector', 'Average Monthly Return'], tablefmt='grid'))


#Further analysis can be done by calculating other metrics such as volatility, cumulative returns etc. per sector.
# Example visualization
sector_df = pd.DataFrame(sector_performance, columns=['Sector', 'Average Monthly Return'])
plt.figure(figsize=(10, 6))
sns.barplot(x='Sector', y='Average Monthly Return', data=sector_df, palette='viridis')
plt.title('Average Monthly Return by Sector')
plt.xlabel('Sector')
plt.ylabel('Average Monthly Return')
plt.xticks(rotation=45, ha='right') # Rotates x-axis labels for better readability
plt.tight_layout()
plt.show()

# prompt: Calculate sector performance metrics and save csv file  (e.g., average yearly return)

# Assuming 'sector_performance' DataFrame from previous code
sector_performance_df = pd.DataFrame(sector_performance, columns=['Sector', 'Average Monthly Return'])

# Save the sector performance data to a CSV file
sector_performance_df.to_csv('sector_performance.csv', index=False)